# v2.1 Improvements Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Ship five improvements — Setapp pre-flight check, `bundle check --path`, no-header AppList files, Bundle→AppList terminology rename, and `dump` moved under `bundle`.

**Architecture:** All changes are self-contained: a new `SetappEnvironment` helper + closure in `Dependencies` for mockability; a filesystem-only check in `BundleCheckCommand`; a pure rename of `BundleFile` → `AppListFile` with default path `~/.setapp/AppList`; `DumpCommand` deleted and `BundleDumpCommand` extended with `--list`.

**Tech Stack:** Swift 5.9, ArgumentParser, XCTest. No new dependencies.

---

## Task 1: Add `SetappEnvironment` and wire it into `Dependencies`

**Files:**
- Create: `Sources/SetappCLI/Helpers/SetappEnvironment.swift`
- Modify: `Sources/SetappCLI/Protocols/Dependencies.swift`
- Modify: `Tests/SetappCLITests/Helpers/CommandTestCase.swift`

---

**Step 1: Write the failing test**

Add a new test file `Tests/SetappCLITests/Helpers/SetappEnvironmentTests.swift`:

```swift
@testable import SetappCLI
import XCTest

final class SetappEnvironmentTests: XCTestCase {
    // Verifies that the mock no-op installed by CommandTestCase actually no-ops.
    func testVerifyEnvironmentDefaultIsLive() {
        // After reset(), the live verifier is restored — it's a non-nil closure.
        XCTAssertNotNil(Dependencies.verifyEnvironment as Any)
    }

    // Verifies that substituting a throwing closure propagates the error.
    func testSubstitutedVerifierCanThrow() {
        let expected = SetappError.generalError(message: "not installed")
        Dependencies.verifyEnvironment = { throw expected }

        XCTAssertThrowsError(try Dependencies.verifyEnvironment()) { error in
            XCTAssertEqual(error.localizedDescription, expected.localizedDescription)
        }

        // Clean up
        Dependencies.reset()
    }
}
```

**Step 2: Run tests to verify they fail**

```bash
cd /Users/maximlevey/src/setapp-cli
swift test --filter SetappEnvironmentTests 2>&1 | tail -20
```

Expected: compile error — `Dependencies.verifyEnvironment` does not exist yet.

---

**Step 3: Create `SetappEnvironment.swift`**

```swift
import Foundation

/// Verifies that Setapp is installed and the user is logged in.
enum SetappEnvironment {
    private static let setappAppPaths: [URL] = [
        URL(fileURLWithPath: "/Applications/Setapp.app"),
        FileManager.default.homeDirectoryForCurrentUser
            .appendingPathComponent("Applications/Setapp.app")
    ]

    /// Throws a descriptive error if Setapp is not installed or the user is not logged in.
    static func verify() throws {
        guard setappAppPaths.contains(where: {
            FileManager.default.fileExists(atPath: $0.path)
        }) else {
            throw SetappError.generalError(
                message: "Setapp is not installed. Download it at setapp.com."
            )
        }

        guard FileManager.default.fileExists(atPath: URL.setappDatabase.path) else {
            throw SetappError.generalError(
                message: "Setapp is installed but you are not logged in." +
                    " Open Setapp and sign in to continue."
            )
        }
    }
}
```

**Step 4: Add `verifyEnvironment` to `Dependencies`**

Replace the full contents of `Sources/SetappCLI/Protocols/Dependencies.swift` with:

```swift
import Foundation

/// Dependency container for injectable services.
///
/// Commands use this container to access dependencies, allowing tests
/// to substitute mock implementations.
enum Dependencies {
    /// App catalogue lookup.
    static var lookup: AppLookup = LiveDatabase()

    /// App install/uninstall service.
    static var installer: AppInstaller = LiveInstaller()

    /// App installation detector.
    static var detector: AppDetecting = LiveDetector()

    /// Environment readiness check. Replaced with a no-op in tests.
    static var verifyEnvironment: () throws -> Void = SetappEnvironment.verify

    /// Reset all dependencies to their live defaults.
    static func reset() {
        lookup = LiveDatabase()
        installer = LiveInstaller()
        detector = LiveDetector()
        verifyEnvironment = SetappEnvironment.verify
    }
}
```

**Step 5: Mock `verifyEnvironment` in `CommandTestCase`**

In `Tests/SetappCLITests/Helpers/CommandTestCase.swift`, add one line to `setUp()` (after the existing mock assignments) and one line to `tearDown()` (before `Dependencies.reset()`):

In `setUp()`, after `Printer.isDebug = false`, add:
```swift
Dependencies.verifyEnvironment = { /* no-op in tests */ }
```

`tearDown()` already calls `Dependencies.reset()` which restores the live closure, so no change needed there.

**Step 6: Run the tests**

```bash
swift test --filter SetappEnvironmentTests 2>&1 | tail -20
```

Expected: 2 tests pass.

**Step 7: Run the full suite to confirm nothing regressed**

```bash
swift test 2>&1 | tail -5
```

Expected: all tests pass.

**Step 8: Commit**

```bash
git add Sources/SetappCLI/Helpers/SetappEnvironment.swift \
        Sources/SetappCLI/Protocols/Dependencies.swift \
        Tests/SetappCLITests/Helpers/CommandTestCase.swift \
        Tests/SetappCLITests/Helpers/SetappEnvironmentTests.swift
git commit -m "feat: add SetappEnvironment pre-flight verifier"
```

---

## Task 2: Wire `verify` into all relevant commands

**Files to modify** (add `try Dependencies.verifyEnvironment()` immediately after `globals.apply()`):

- `Sources/SetappCLI/Commands/Install/InstallCommand.swift`
- `Sources/SetappCLI/Commands/Remove/RemoveCommand.swift`
- `Sources/SetappCLI/Commands/Reinstall/ReinstallCommand.swift`
- `Sources/SetappCLI/Commands/List/ListCommand.swift`
- `Sources/SetappCLI/Commands/Check/CheckCommand.swift`
- `Sources/SetappCLI/Commands/Bundle/BundleInstallCommand.swift`
- `Sources/SetappCLI/Commands/Bundle/BundleDumpCommand.swift`
- `Sources/SetappCLI/Commands/Bundle/BundleCheckCommand.swift`
- `Sources/SetappCLI/Commands/Bundle/BundleListCommand.swift`
- `Sources/SetappCLI/Commands/Bundle/BundleCleanupCommand.swift`

`BundleEditCommand` is **excluded** — it only manages a plain-text file.

---

**Step 1: Write a failing test**

In `Tests/SetappCLITests/Commands/InstallCommandTests.swift`, add:

```swift
func testVerifyEnvironmentCalledOnInstall() throws {
    let expected = SetappError.generalError(message: "not installed")
    Dependencies.verifyEnvironment = { throw expected }

    mockLookup.apps = [SetappApp(identifier: 1, name: "Proxyman")]
    var cmd = try InstallCommand.parse(["Proxyman"])

    XCTAssertThrowsError(try cmd.run()) { error in
        XCTAssertEqual(error.localizedDescription, expected.localizedDescription)
    }
}
```

Run: `swift test --filter InstallCommandTests/testVerifyEnvironmentCalledOnInstall`
Expected: FAIL — `InstallCommand` does not call `verifyEnvironment` yet.

---

**Step 2: Add `try Dependencies.verifyEnvironment()` to each command**

In every `run()` method listed above, the pattern is the same. Example for `InstallCommand`:

```swift
mutating func run() throws {
    globals.apply()
    try Dependencies.verifyEnvironment()   // ← add this line
    // ... rest of existing implementation
}
```

Open each file and add this single line after `globals.apply()`.

---

**Step 3: Run the tests**

```bash
swift test 2>&1 | tail -5
```

Expected: all tests pass (the `CommandTestCase` setUp mocks `verifyEnvironment` to a no-op).

**Step 4: Commit**

```bash
git add Sources/SetappCLI/Commands
git commit -m "feat: wire SetappEnvironment.verify into all DB/XPC commands"
```

---

## Task 3: Add `--list` to `bundle dump`, delete top-level `dump`

**Files:**
- Modify: `Sources/SetappCLI/Commands/Bundle/BundleDumpCommand.swift`
- Modify: `Tests/SetappCLITests/Commands/BundleDumpCommandTests.swift`
- Delete: `Sources/SetappCLI/Commands/Dump/DumpCommand.swift`
- Delete: `Tests/SetappCLITests/Commands/DumpCommandTests.swift`
- Modify: `Sources/SetappCLI/Commands/SetappCLI.swift`

---

**Step 1: Write failing tests for `--list` on `bundle dump`**

In `Tests/SetappCLITests/Commands/BundleDumpCommandTests.swift`, add:

```swift
func testListFlagPrintsApps() throws {
    try XCTSkipUnless(setappDirectoryExists, "Setapp directory not present on this machine")

    mockDetector.allInstalledNames = ["Proxyman", "Bartender"]

    var cmd = try BundleDumpCommand.parse(["--list"])
    XCTAssertNoThrow(try cmd.run())
}

func testListFlagDoesNotWriteFile() throws {
    try XCTSkipUnless(setappDirectoryExists, "Setapp directory not present on this machine")

    let tmp = TempDirectory()
    let filePath = tmp.url.appendingPathComponent("should-not-exist").path

    mockDetector.allInstalledNames = ["Proxyman"]

    var cmd = try BundleDumpCommand.parse(["--list", "--file", filePath])
    try cmd.run()

    XCTAssertFalse(FileManager.default.fileExists(atPath: filePath),
                   "File should not be written when --list is passed")
}
```

Run: `swift test --filter BundleDumpCommandTests`
Expected: compile error — `BundleDumpCommand` has no `--list` flag.

---

**Step 2: Add `--list` to `BundleDumpCommand`**

Replace the full contents of `Sources/SetappCLI/Commands/Bundle/BundleDumpCommand.swift`:

```swift
import ArgumentParser
import Foundation

struct BundleDumpCommand: ParsableCommand {
    static let configuration: CommandConfiguration = .init(
        commandName: "dump",
        abstract: "Write installed apps to a bundle file."
    )

    @OptionGroup var globals: GlobalOptions

    @Option(name: .shortAndLong, help: "Bundle file path (default: ~/.setapp/bundle).")
    var file: String?

    @Flag(name: .shortAndLong, help: "Print app names to stdout instead of writing a file.")
    var list: Bool = false

    mutating func run() throws {
        globals.apply()
        try Dependencies.verifyEnvironment()

        let installed: [String] = try BundleFile.fetchInstalledNames()
        if installed.isEmpty { return }

        if list {
            for name in installed {
                Printer.log(name)
            }
            return
        }

        let path: URL = BundleFile.resolvePath(flagValue: file)
        Printer.info("Saving \(installed.count) app(s) to \(path.path)")
        try BundleFile.write(names: installed, to: path)
        Printer.log("Wrote \(installed.count) app(s) to \(path.path)")
    }
}
```

**Step 3: Run `BundleDumpCommandTests`**

```bash
swift test --filter BundleDumpCommandTests 2>&1 | tail -10
```

Expected: all pass.

---

**Step 4: Migrate `DumpCommandTests` into `BundleDumpCommandTests`**

The four tests in `DumpCommandTests.swift` are identical to what `BundleDumpCommandTests` already has, now that `--list` is added. Delete `DumpCommandTests.swift` — no migration needed; the coverage is already there.

```bash
rm Tests/SetappCLITests/Commands/DumpCommandTests.swift
```

---

**Step 5: Delete `DumpCommand.swift` and update `SetappCLI.swift`**

```bash
rm Sources/SetappCLI/Commands/Dump/DumpCommand.swift
```

In `Sources/SetappCLI/Commands/SetappCLI.swift`, update the `configuration`:

```swift
@main
struct SetappCLI: ParsableCommand {
    static let configuration: CommandConfiguration = .init(
        commandName: "setapp-cli",
        abstract: "Install and manage Setapp apps from the command line.",
        discussion: """
        Common usage:
            setapp-cli install <app>         Install a single app
            setapp-cli list                  List installed apps
            setapp-cli bundle dump           Save installed apps to an AppList file
            setapp-cli bundle install        Install all apps from an AppList file
            setapp-cli check                 Find apps available via Setapp
        """,
        version: "2.1.0",
        subcommands: [
            InstallCommand.self,
            RemoveCommand.self,
            ReinstallCommand.self,
            ListCommand.self,
            CheckCommand.self,
            BundleCommand.self    // DumpCommand.self removed
        ]
    )
}
```

**Step 6: Run full test suite**

```bash
swift test 2>&1 | tail -5
```

Expected: all tests pass, test count is lower by 4 (deleted `DumpCommandTests`).

**Step 7: Commit**

```bash
git add Sources/SetappCLI/Commands/Bundle/BundleDumpCommand.swift \
        Sources/SetappCLI/Commands/SetappCLI.swift \
        Tests/SetappCLITests/Commands/BundleDumpCommandTests.swift
git rm Sources/SetappCLI/Commands/Dump/DumpCommand.swift \
       Tests/SetappCLITests/Commands/DumpCommandTests.swift
git commit -m "feat: add --list to bundle dump, remove top-level dump command"
```

---

## Task 4: Remove header from AppList file writes

**Files:**
- Modify: `Sources/SetappCLI/Helpers/BundleFile.swift`
- Modify: `Sources/SetappCLI/Commands/Bundle/BundleEditCommand.swift`
- Modify: `Tests/SetappCLITests/Commands/BundleEditCommandTests.swift`

---

**Step 1: Update the write test to expect no header**

In `Tests/SetappCLITests/Commands/BundleDumpCommandTests.swift`, update `testWritesBundleFileWhenAppsInstalled`:

```swift
func testWritesBundleFileWhenAppsInstalled() throws {
    try XCTSkipUnless(setappDirectoryExists, "Setapp directory not present on this machine")

    let tmp = TempDirectory()
    let filePath = tmp.url.appendingPathComponent("test-bundle").path

    mockDetector.allInstalledNames = ["Proxyman", "Bartender"]

    var cmd = try BundleDumpCommand.parse(["--file", filePath])
    try cmd.run()

    let content = try String(contentsOfFile: filePath, encoding: .utf8)
    XCTAssertFalse(content.hasPrefix("#"), "Written file must not start with a comment header")
    XCTAssertTrue(content.contains("Proxyman"), "Written file must contain app names")
}
```

In `Tests/SetappCLITests/Commands/BundleEditCommandTests.swift`, update `testCreatesFileWithHeaderWhenMissing` to expect an **empty** file:

```swift
func testCreatesEmptyFileWhenMissing() throws {
    let tmp = TempDirectory()
    let filePath = tmp.url.appendingPathComponent("new-bundle").path
    setenv("EDITOR", "true", 1)
    defer { unsetenv("EDITOR") }

    var cmd = try BundleEditCommand.parse(["--file", filePath])
    try cmd.run()

    XCTAssertTrue(FileManager.default.fileExists(atPath: filePath),
                  "File should be created")
    let content = try String(contentsOfFile: filePath, encoding: .utf8)
    XCTAssertEqual(content, "", "Newly created AppList file should be empty")
}
```

Run: `swift test --filter "BundleDumpCommandTests|BundleEditCommandTests"`
Expected: the two updated tests FAIL.

---

**Step 2: Update `BundleFile.write()` to strip the header**

In `Sources/SetappCLI/Helpers/BundleFile.swift`, replace the `write(names:to:)` method:

```swift
/// Write sorted app names to an AppList file (no header, one name per line).
static func write(names: [String], to path: URL) throws {
    try FileManager.default.createDirectory(
        at: path.deletingLastPathComponent(),
        withIntermediateDirectories: true
    )

    let sorted: [String] = names.sorted {
        $0.localizedCaseInsensitiveCompare($1) == .orderedAscending
    }

    let content: String = sorted.joined(separator: "\n") + "\n"
    try content.write(to: path, atomically: true, encoding: .utf8)
}
```

Also remove the `import Foundation` line for `DateFormatter` if it's no longer needed (check — `Foundation` is still needed for `FileManager`, `URL`, etc., so keep it).

**Step 3: Update `BundleEditCommand` to create an empty file**

In `Sources/SetappCLI/Commands/Bundle/BundleEditCommand.swift`, replace the file-creation block:

```swift
// Create an empty file if it doesn't exist.
if !FileManager.default.fileExists(atPath: path.path) {
    try FileManager.default.createDirectory(
        at: path.deletingLastPathComponent(),
        withIntermediateDirectories: true
    )
    try "".write(to: path, atomically: true, encoding: .utf8)
}
```

(Remove the `let header: String = ...` block entirely.)

**Step 4: Run the tests**

```bash
swift test --filter "BundleDumpCommandTests|BundleEditCommandTests" 2>&1 | tail -10
```

Expected: all pass.

**Step 5: Commit**

```bash
git add Sources/SetappCLI/Helpers/BundleFile.swift \
        Sources/SetappCLI/Commands/Bundle/BundleEditCommand.swift \
        Tests/SetappCLITests/Commands/BundleDumpCommandTests.swift \
        Tests/SetappCLITests/Commands/BundleEditCommandTests.swift
git commit -m "feat: remove header comment from AppList file writes"
```

---

## Task 5: Rename `BundleFile` → `AppListFile` throughout

This is a mechanical rename. Do all steps, then verify with `swift build`.

**Files:**

| Action | Path |
|--------|------|
| Rename + edit | `Sources/SetappCLI/Helpers/BundleFile.swift` → `AppListFile.swift` |
| Edit | `Sources/SetappCLI/Extensions/URL+Extension.swift` |
| Edit | `Sources/SetappCLI/Model/SetappError.swift` |
| Edit | `Sources/SetappCLI/Commands/Bundle/BundleCommand.swift` |
| Edit | `Sources/SetappCLI/Commands/Bundle/BundleCheckCommand.swift` |
| Edit | `Sources/SetappCLI/Commands/Bundle/BundleDumpCommand.swift` |
| Edit | `Sources/SetappCLI/Commands/Bundle/BundleInstallCommand.swift` |
| Edit | `Sources/SetappCLI/Commands/Bundle/BundleListCommand.swift` |
| Edit | `Sources/SetappCLI/Commands/Bundle/BundleCleanupCommand.swift` |
| Edit | `Sources/SetappCLI/Commands/Bundle/BundleEditCommand.swift` |
| Edit | All test files referencing `BundleFile`, `bundleFileNotFound`, `SETAPP_BUNDLE_FILE` |

---

**Step 1: Rename and update `BundleFile.swift`**

```bash
git mv Sources/SetappCLI/Helpers/BundleFile.swift \
        Sources/SetappCLI/Helpers/AppListFile.swift
```

Open `Sources/SetappCLI/Helpers/AppListFile.swift` and:
- Rename the enum: `enum BundleFile` → `enum AppListFile`
- Update the env var reference: `"SETAPP_BUNDLE_FILE"` → `"SETAPP_APP_LIST_FILE"`
- Update `URL.defaultBundlePath` → `URL.defaultAppListPath`
- Update `SetappError.bundleFileNotFound` → `SetappError.appListFileNotFound`
- Update `SetappError.bundleFileEmpty` → `SetappError.appListFileEmpty` (if present)
- Update the doc comments: "bundle file" → "AppList file"

Full result for the `resolvePath` and `parse` methods:

```swift
/// AppList file read/write operations.
enum AppListFile {
    /// Resolve AppList file path from flag value, env var, or default.
    static func resolvePath(flagValue: String?) -> URL {
        if let flagValue, !flagValue.isEmpty {
            return URL(fileURLWithPath: (flagValue as NSString).expandingTildeInPath)
        }
        if let envPath = ProcessInfo.processInfo.environment["SETAPP_APP_LIST_FILE"] {
            return URL(fileURLWithPath: (envPath as NSString).expandingTildeInPath)
        }
        return URL.defaultAppListPath
    }

    /// Parse an AppList file, returning app names (comments and blanks stripped).
    static func parse(at path: URL) throws -> [String] {
        guard FileManager.default.fileExists(atPath: path.path) else {
            throw SetappError.appListFileNotFound(path: path.path)
        }

        let content: String = try String(contentsOf: path, encoding: .utf8)
        return content
            .components(separatedBy: .newlines)
            .map { $0.components(separatedBy: "#").first ?? "" }
            .map { $0.trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
    }

    /// Verify Setapp directories exist and return installed app names, or throw/warn.
    static func fetchInstalledNames() throws -> [String] {
        let appsDirs: [URL] = URL.setappAppsDirectories
        guard appsDirs.contains(where: { FileManager.default.directoryExists(at: $0.path) }) else {
            throw SetappError.setappAppsDirectoryNotFound(
                path: appsDirs.map(\.path).joined(separator: ", ")
            )
        }

        let installed: [String] = Dependencies.detector.installedAppNames()
        if installed.isEmpty {
            Printer.warning("No Setapp apps installed")
        }
        return installed
    }

    /// Write sorted app names to an AppList file (no header, one name per line).
    static func write(names: [String], to path: URL) throws {
        try FileManager.default.createDirectory(
            at: path.deletingLastPathComponent(),
            withIntermediateDirectories: true
        )

        let sorted: [String] = names.sorted {
            $0.localizedCaseInsensitiveCompare($1) == .orderedAscending
        }

        let content: String = sorted.joined(separator: "\n") + "\n"
        try content.write(to: path, atomically: true, encoding: .utf8)
    }
}
```

---

**Step 2: Update `URL+Extension.swift`**

Replace `defaultBundlePath`:

```swift
/// The default AppList file path (~/.setapp/AppList).
static var defaultAppListPath: URL {
    setappDirectory.appendingPathComponent("AppList")
}
```

Remove the old `defaultBundlePath` property entirely.

---

**Step 3: Update `SetappError.swift`**

Rename two cases:
- `case bundleFileNotFound(path: String)` → `case appListFileNotFound(path: String)`
- `case bundleFileEmpty` → `case appListFileEmpty`

Update the `description` switch:
```swift
case let .appListFileNotFound(path):
    "no such file: \(path)"
case .appListFileEmpty:
    "AppList file is empty"
```

---

**Step 4: Update all command source files**

In every source file listed in the table above, do a find-and-replace:
- `BundleFile.` → `AppListFile.`
- `"Bundle file path (default: ~/.setapp/bundle)."` → `"AppList file path (default: ~/.setapp/AppList)."`
- `"bundle file"` → `"AppList file"` (in abstracts and discussion text)
- `"bundle apps"` → `"AppList apps"` (in abstracts)

Specific abstracts and discussion text to update:

**`BundleCommand.swift`:**
```swift
abstract: "Manage AppList files for saving and restoring app lists.",
discussion: """
An AppList file is a plain-text list of app names (one per line).
Use 'bundle dump' on one Mac, then 'bundle install' on another
to replicate your Setapp app setup.

Default AppList path: ~/.setapp/AppList
""",
```

**`BundleCheckCommand.swift`:**
```swift
abstract: "Check that all AppList apps are installed (exit 1 if any missing)."
```

**`BundleDumpCommand.swift`:**
```swift
abstract: "Write installed apps to an AppList file."
```

**`BundleInstallCommand.swift`:**
```swift
abstract: "Install all apps from an AppList file."
```

**`BundleListCommand.swift`:**
```swift
abstract: "List apps in the AppList file."
```

**`BundleCleanupCommand.swift`:**
```swift
abstract: "Uninstall Setapp apps not listed in the AppList file."
// Also update the inline string:
Printer.info("Removing \(extras.count) app(s) not in AppList")
```

**`BundleEditCommand.swift`:**
```swift
abstract: "Open the AppList file in $EDITOR (or 'open' if unset)."
```

---

**Step 5: Update all test files**

Search for `bundleFileNotFound` in the test suite:

```bash
grep -r "bundleFileNotFound\|BundleFile\|SETAPP_BUNDLE_FILE" \
    Tests/SetappCLITests --include="*.swift" -l
```

In each file found, replace:
- `BundleFile.` → `AppListFile.`
- `bundleFileNotFound` → `appListFileNotFound`
- `bundleFileEmpty` → `appListFileEmpty`
- `"SETAPP_BUNDLE_FILE"` → `"SETAPP_APP_LIST_FILE"`

---

**Step 6: Build to verify**

```bash
swift build 2>&1 | grep -E "error:|warning:" | head -20
```

Expected: no errors. Fix any that appear (most will be missed `BundleFile` references).

**Step 7: Run full test suite**

```bash
swift test 2>&1 | tail -5
```

Expected: all tests pass.

**Step 8: Commit**

```bash
git add -A
git commit -m "refactor: rename BundleFile → AppListFile, default path ~/.setapp/AppList"
```

---

## Task 6: Add `--path` to `bundle check`

**Files:**
- Modify: `Sources/SetappCLI/Commands/Bundle/BundleCheckCommand.swift`
- Modify: `Tests/SetappCLITests/Commands/BundleCheckCommandTests.swift`

---

**Step 1: Write failing tests**

Replace `Tests/SetappCLITests/Commands/BundleCheckCommandTests.swift` with:

```swift
import ArgumentParser
@testable import SetappCLI
import XCTest

final class BundleCheckCommandTests: CommandTestCase {

    // MARK: - --path flag: all installed

    func testAllInstalledWithCustomPath() throws {
        let tmp = TempDirectory()

        // Create fake .app bundles in a temp "Applications" directory.
        let appsDir = tmp.url.appendingPathComponent("Apps")
        try FileManager.default.createDirectory(
            at: appsDir.appendingPathComponent("Proxyman.app"),
            withIntermediateDirectories: true
        )
        try FileManager.default.createDirectory(
            at: appsDir.appendingPathComponent("Bartender.app"),
            withIntermediateDirectories: true
        )

        let listPath = tmp.createFile(named: "AppList", content: "Proxyman\nBartender\n")
        var cmd = try BundleCheckCommand.parse([
            "--file", listPath.path,
            "--path", appsDir.path
        ])

        XCTAssertNoThrow(try cmd.run())
    }

    // MARK: - --path flag: missing apps

    func testMissingAppsWithCustomPath() throws {
        let tmp = TempDirectory()

        let appsDir = tmp.url.appendingPathComponent("Apps")
        // Only Proxyman.app exists; Bartender.app is missing.
        try FileManager.default.createDirectory(
            at: appsDir.appendingPathComponent("Proxyman.app"),
            withIntermediateDirectories: true
        )

        let listPath = tmp.createFile(named: "AppList", content: "Proxyman\nBartender\n")
        var cmd = try BundleCheckCommand.parse([
            "--file", listPath.path,
            "--path", appsDir.path
        ])

        XCTAssertThrowsError(try cmd.run()) { error in
            guard let exitError = error as? ExitCode else {
                return XCTFail("Expected ExitCode, got \(type(of: error))")
            }
            XCTAssertEqual(exitError.rawValue, 1)
        }
    }

    // MARK: - Default paths (no --path)

    func testDefaultPathsUsedWhenNoPathFlag() throws {
        // All apps in the list are absent from /Applications and ~/Applications,
        // so the command should exit 1.
        let tmp = TempDirectory()
        let listPath = tmp.createFile(named: "AppList",
                                      content: "ThisAppDefinitelyDoesNotExist999\n")
        var cmd = try BundleCheckCommand.parse(["--file", listPath.path])

        XCTAssertThrowsError(try cmd.run()) { error in
            guard let exitError = error as? ExitCode else {
                return XCTFail("Expected ExitCode, got \(type(of: error))")
            }
            XCTAssertEqual(exitError.rawValue, 1)
        }
    }

    // MARK: - AppList file not found

    func testAppListFileNotFound() throws {
        var cmd = try BundleCheckCommand.parse(["--file", "/nonexistent/path/AppList"])

        XCTAssertThrowsError(try cmd.run()) { error in
            guard let setappError = error as? SetappError else {
                return XCTFail("Expected SetappError, got \(type(of: error))")
            }
            if case .appListFileNotFound = setappError {
                // Expected
            } else {
                XCTFail("Expected appListFileNotFound, got \(setappError)")
            }
        }
    }
}
```

Run: `swift test --filter BundleCheckCommandTests`
Expected: compile error — `BundleCheckCommand` has no `--path` option.

---

**Step 2: Rewrite `BundleCheckCommand.swift`**

```swift
import ArgumentParser
import Foundation

struct BundleCheckCommand: ParsableCommand {
    static let configuration: CommandConfiguration = .init(
        commandName: "check",
        abstract: "Check that all AppList apps are installed (exit 1 if any missing)."
    )

    @OptionGroup var globals: GlobalOptions

    @Option(name: .shortAndLong, help: "AppList file path (default: ~/.setapp/AppList).")
    var file: String?

    @Option(name: .shortAndLong,
            help: "Directory to check for installed apps (default: /Applications and ~/Applications).")
    var path: String?

    mutating func run() throws {
        globals.apply()
        try Dependencies.verifyEnvironment()

        let listPath: URL = AppListFile.resolvePath(flagValue: file)
        let names: [String] = try AppListFile.parse(at: listPath)
        let missing: [String] = names.filter { !isInstalled($0) }

        if missing.isEmpty {
            Printer.log("All AppList apps are installed.")
            return
        }

        Printer.warning("\(missing.count) app(s) from AppList are not installed:")
        for name in missing {
            Printer.log(name)
        }
        throw ExitCode(1)
    }

    /// Returns true if `name.app` exists in the given search path(s).
    private func isInstalled(_ name: String) -> Bool {
        if let searchPath = path {
            let expanded = (searchPath as NSString).expandingTildeInPath
            return FileManager.default.fileExists(atPath: "\(expanded)/\(name).app")
        }
        let dirs = [
            "/Applications",
            FileManager.default.homeDirectoryForCurrentUser
                .appendingPathComponent("Applications").path
        ]
        return dirs.contains { dir in
            FileManager.default.fileExists(atPath: "\(dir)/\(name).app")
        }
    }
}
```

**Step 3: Run the tests**

```bash
swift test --filter BundleCheckCommandTests 2>&1 | tail -10
```

Expected: all 4 tests pass.

**Step 4: Run full suite**

```bash
swift test 2>&1 | tail -5
```

Expected: all pass.

**Step 5: Commit**

```bash
git add Sources/SetappCLI/Commands/Bundle/BundleCheckCommand.swift \
        Tests/SetappCLITests/Commands/BundleCheckCommandTests.swift
git commit -m "feat: add --path flag to bundle check, use filesystem check"
```

---

## Task 7: Update `test-local.sh`

**File:** `test-local.sh`

---

**Step 1: Update `dump` references to `bundle dump`**

Find and replace the two occurrences:

1. `"${CLI}" dump --list 2>&1` → `"${CLI}" bundle dump --list 2>&1`
2. `"${CLI}" dump --file "${bundle_tmp}" >/dev/null 2>&1` → `"${CLI}" bundle dump --file "${bundle_tmp}" >/dev/null 2>&1`

Also update the assertion for the header test — `dump --file` now writes no header, just app names. The existing test `'dump --file writes header comment'` currently checks for `^# setapp bundle`. After this change, that test should instead verify the file contains only app names and NO header:

Replace the header-check test block:

```bash
# --- bundle dump --file ---
BUNDLE_TMP="${tmpdir_test}/test-bundle"
if "${CLI}" bundle dump --file "${BUNDLE_TMP}" >/dev/null 2>&1; then
  pass 'bundle dump --file exits 0'
else
  fail 'bundle dump --file exits 0'
fi

if ! grep -q '^#' "${BUNDLE_TMP}" 2>/dev/null; then
  pass 'bundle dump --file writes no header comment'
else
  fail 'bundle dump --file writes no header comment'
fi

if grep -qi 'proxyman\|cleanmymac\|cleanshot' "${BUNDLE_TMP}" 2>/dev/null; then
  pass 'bundle dump --file contains app names'
else
  fail 'bundle dump --file contains app names'
fi
```

Also update the `bundle dump --list` block:

```bash
# --- bundle dump --list ---
dump_list=$("${CLI}" bundle dump --list 2>&1) || true
if echo "${dump_list}" | grep -q 'Proxyman\|CleanMyMac\|CleanShot'; then
  pass 'bundle dump --list prints installed app names'
else
  fail 'bundle dump --list prints installed app names'
fi
```

Update the `bundle check` test to use `--path` for deterministic results (the default check against `/Applications` requires real apps, so keep as-is but update the check that verifies the newly-dumped bundle — it already uses `--file` pointing at `BUNDLE_TMP`):

```bash
# --- bundle check ---
if "${CLI}" bundle check --file "${BUNDLE_TMP}" --path /Applications/Setapp >/dev/null 2>&1; then
  pass 'bundle check passes on freshly-dumped bundle'
else
  fail 'bundle check passes on freshly-dumped bundle'
fi
```

---

**Step 2: Run read-only tests**

```bash
./test-local.sh --read-only
```

Expected: 15 passed, 0 failed.

**Step 3: Commit**

```bash
git add test-local.sh
git commit -m "fix: update test-local.sh for bundle dump subcommand and AppList changes"
```

---

## Task 8: Update README and bump version

**Files:**
- Modify: `README.md`
- Modify: `Sources/SetappCLI/Commands/SetappCLI.swift` (version already set to 2.1.0 in Task 3)

---

**Step 1: Update README usage block**

Find the `SUBCOMMANDS` section in `README.md` and replace it:

```markdown
SUBCOMMANDS:
  install                 Install a Setapp app by name.
  remove                  Uninstall a Setapp app.
  reinstall               Uninstall then reinstall a Setapp app.
  list                    List installed Setapp apps.
  check                   Find locally installed apps that are available via Setapp.
  bundle                  Manage AppList files for saving and restoring app lists.
```

Also update any prose that mentions:
- "bundle file" → "AppList file"
- "`dump`" as a top-level command → "`bundle dump`"
- `~/.setapp/bundle` → `~/.setapp/AppList`
- `SETAPP_BUNDLE_FILE` → `SETAPP_APP_LIST_FILE`

---

**Step 2: Verify version**

```bash
swift build 2>&1 | tail -1
.build/debug/setapp-cli --version
```

Expected: `2.1.0`

**Step 3: Commit**

```bash
git add README.md Sources/SetappCLI/Commands/SetappCLI.swift
git commit -m "docs: update README for v2.1 — AppList terminology and bundle dump"
```

---

## Task 9: Final verification

**Step 1: Full build**

```bash
swift build --configuration release --arch arm64 --arch x86_64 \
    -Xlinker -rpath -Xlinker \
    "$HOME/Library/Application Support/Setapp/LaunchAgents/Setapp.app/Contents/Frameworks" \
    2>&1 | tail -3
```

Expected: `Build complete!`

**Step 2: Full test suite**

```bash
swift test 2>&1 | tail -5
```

Expected: all tests pass, 0 failures.

**Step 3: Lint**

```bash
swiftlint --strict 2>&1 | tail -5
swiftformat . 2>&1 | tail -3
```

Expected: 0 violations, 0 changes.

**Step 4: Local functional tests (read-only)**

```bash
./test-local.sh --read-only
```

Expected: 15 passed, 0 failed.

**Step 5: Confirm `DumpCommand` is truly gone**

```bash
.build/debug/setapp-cli --help | grep -v dump || echo "dump not in top-level help"
```

Expected: `dump` does not appear as a top-level subcommand.

```bash
.build/debug/setapp-cli bundle --help | grep dump
```

Expected: `dump` appears as a `bundle` subcommand.

**Step 6: Confirm `bundle check --path` works**

```bash
mkdir -p /tmp/testapps/TestApp.app
echo "TestApp" > /tmp/testapps-list
.build/debug/setapp-cli bundle check --file /tmp/testapps-list --path /tmp/testapps
echo "exit: $?"
rm -rf /tmp/testapps /tmp/testapps-list
```

Expected: `All AppList apps are installed.` and exit 0.

**Step 7: Tag the release**

```bash
git tag v2.1.0
```
